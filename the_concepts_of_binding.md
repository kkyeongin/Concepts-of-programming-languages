# The Concepts of Binding

> Concepts of Programming Languages 11th Edition - Sebesta, Robert W. 에 나온 내용에 관해 설명하고 있습니다.

`Binding`은 attribute 와 entity의 연결을 의미 합니다. 변수(variable)와 type , 연산(operation)과 symbol과 같이 말이죠.

바인딩이 이루어지는 시간을 `바인딩 시간`(binding time)이라고 합니다. 바인딩 및 바인딩 시간은 프로그래밍 언어 체계(semantics)에서 중요한 개념 입니다.

1. 언어 디자인 시간 (Language design time)
2. 언어 구현 시간 (Language implementation time)
3. 컴파일 시간 (Compile time)
4. 로드 시간 (Load time)
5. 링크 시간, 런 타임 (Link Time, Run time)

에 발생할 수 있습니다.

예를 들어, 별표 기호 (*)는 일반적으로 `언어 설계` 시 곱셈 연산에 바인딩 됩니다.

```c++
T operator*(T a, T b){return a*b;}
```

int(Type) 같은 데이터 타입은, `언어 구현 시간`에 가능한 범위의 값에 바인딩 됩니다.

```c++
int count = 5;
```

`컴파일 타임`시  Java 프로그램의 변수는 특정 데이터 타입(particular data type)에 연결됩니다.

프로그램이 메모리(memory)에 로드(load) 될 때 변수(variable)는 스토리지 셀(storage cell, memory cell)에 바인딩 될 수 있습니다. 보통 static type이 memory cell에 바인드 됩니다.

Java의 경우 메소드에서 선언 된 변수같이 일부 케이스는 `런 타임`에 동일한 바인딩이 발생하지 않습니다. nonstatic local variable이 런타임에 바인드 됩니다. 라이브러리 서브 프로그램에 대한 호출(call)은 `링크 타임`(link time)에 서브 프로그램 코드에 바인드 됩니다.

이 문장에서 일부에 대한 일부 바인딩 및 바인딩 시간은 다음과 같습니다.

```c++
T count = count + 5;
```

* count의 Type은 `컴파일 타임`에 바인드 된다.
* count의 가능한 값셋(The set of possible values)은 `컴파일러 디자인 시간`에 바인딩됩니다.
* 피연산자(count)의 type이 결정되었을 때, 연산자 기호 + 의 `컴파일 타임`에 바인딩을 의미합니다.
* 상수(literal) 5의 내부 표현은 `컴파일러 디자인 타임`에 바인딩됩니다.
* count의 값은 이 문장 실행시 바인딩됩니다.(`런 타임`)

프로그램 엔티티의 속성에 대한 바인딩 시간을 완전히 이해하는 것은 프로그래밍 언어의 의미(semantics)를 이해하기 위한 전제 조건입니다.

## Type Bindings

프로그램에서 변수를 참조하려면 데이터 `type에 연결`돼 있어야 합니다.

이 바인딩의 두 가지 중요한 측면은 유형을 지정하는 방법과 바인딩이 발생하는 시점입니다. 유형은 명시적(explicit) 또는 암시적(implicit) 선언 형식을 통해 정적으로 지정할 수 있습니다.

## Static Type Binding

> 런타임이 시작되기 전에 처음 발생하고 프로그램 실행 전체에 걸쳐 변경되지 않은 경우 바인딩은 static 입니다.

처음 나온 변수의 이름은 프로그램에서는 암시적 선언으로 구성하며, 명시적 선언과 암식적 선언을 모두 Type에 대한 정적 바인딩을 생성합니다.

### 명시적 선언(explicit declaration)

> 명시적 선언은 변수 이름을 나열하고 특정 유형임을 지정하는 프로그램의 명령문

### 암시적 선언(implicit declaration)

> 선언문이 아닌 기본 규칙을 통해 변수를 유형과 연관시키는 수단(a means)

```py
mayBeInt = 1
```

암시적 선언은 따로 type을 명시하지 않아 편하다고 생각할 수 있지만, 신뢰성을 주지 못한다는 단점이 있습니다. 컴파일 과정에서 프로그래머 오류와 오타(typographical error)를 발견 못 할 수 있습니다.

또 다른 유형의 암시적 타입 선언은 컨택스트를 사용하는것 입니다. 이를 `type inference`라 부름니다.

예를 들어 C#에서 변수의 var 선언에는 변수의 유형으로 사용되는 초기 값이 포함 돼야 합니다.

```.net
var = 1; // int
var = "String"; //string
var = 10.1; // float
```

위의 예제는 정적 타입변수이며, 이 타입들은 생명주기동안 선언된 타입으로 고정 됩니다. 변수의 유형이 정적으로 바인드되면 변수의 유형과 이름이 동시에 바인드된다는 의미에서 변수의 이름은 유형에 바인드 된 것으로 간주 될 수 있습니다.

## Dynamic Type Binding

> 바인딩이 런타임 동안 처음 발생하거나 프로그램 실행 과정에서 변경 될 수있는 경우 이를 dynamic 부름니다.

동적 유형 바인딩을 사용하면 변수의 유형이 선언문에 의해 지정되지 않으며 이름의 철자에 의해 결정될 수 없습니다. 변수가 값이 할당되는 대입문에서 타입에 바인드 됩니다. 할당문에 실행됐을때, 할당되는 변수는 할당의 오른쪽에있는 값 타입에 바인딩 됩니다.

`중요한 점은 동적으로 바인딩된 타입은 일식적인(temporary)인 변수의 타입이다.`

* 장점
가장 큰 장점은 유연한(flexibility) 프로그래밍을 할 수 있습니다.
ex. generic program.

* 단점

첫번째로는 `신뢰성이 낮다`. 컴파일러는 type 관련해 오류를 찾을 수 잇지만, 보통 정적 타입에 관련한 타입 검사를 한다. 그러니 정적 타입에서는 관련성이 낮아진다. 그래서 불안정한 타입이 할당 되더라도 에러를 발견하지 못 합니다.

이 단점에서 정적타입을 사용하는 언어에서도 어느 정도 존재합니다. C, C++ 경우, 할당시 자동 캐스팅 되는 경우(LHS = RHS)

가장 큰 단점은 `동적 타입을 바인딩하는 비용`입니다. 동적 속성 바인딩을 구현하는 비용은 특히 실행 시간(execution time)에서 상당히 큽니다. Type checting은 런타임에 무조건 해야하며, 또한 모든 변수는 현재 유형을 유지하기 위해 run-time descriptor가 있어야 합니다. 타입 값마다 스토리지 양이 다르기 때문에, 변수 값에 사용되는 스토리지는 크기가 달라야 합니다.

`결국, 동적 타입 바인딩 언어는 보통 pure interpreter를 컴파일러 보다 구현시 더 사용합니다.`

언어가 순수 인터프리터로 구현 된 경우 동적 타입 바인딩을 수행하는 시간은 해석 시간 끝까지 숨겨 지므로 해당 환경에서 비용이 덜 드는 것처럼 보입니다.

반면에 정적 유형 바인딩을 사용하는 언어는 interpreter로 거의 구현되지 않습니다. 이러한 언어의 프로그램은 매우 효율적인 기계 코드 버전으로 쉽게 변환 될 수 있기 때문입니다.

하지만 JAVA의 경우 JVM Execution Engine의 경우 Compiler를 통해 Byte(.class)로 변환 후 인터프리터 방식을 보안한 JIT 컴파일러(Just-In-Time Compiler)를 통해 네이티브 코드로 변환 후 직접 실행하는 구조입니다.